# Quiz Admin Panel - Next.js Frontend Specification

## Project Overview

Build a modern, responsive admin panel in Next.js for managing quiz questions and categories for the parent education quiz app. The panel should allow content creators to easily create, edit, and organize quiz content without touching code.

## Firebase Firestore Data Model

The admin panel directly modifies data in Firebase Firestore. Understanding the exact data structure is critical for proper implementation.

### Collection: `category/{categoryId}`

Each category document represents a quiz topic/subject area.

**Document Structure:**

```typescript
interface Category {
  title: string; // Display name (e.g., "Motorik / Wachstum / Bewegung")
  description: string; // Brief description shown in category selection
  order: number; // Sort order (1, 2, 3...) for display sequence
  iconName: string; // Material icon name (e.g., "directions_run", "pregnant_woman")
  isPremium: boolean; // Whether category requires premium subscription
}
```

**Example Document:**

```json
// Document ID: "motorik"
{
  "title": "Motorik / Wachstum / Bewegung",
  "description": "Fragen zur motorischen Entwicklung, Wachstum und Bewegung von Kindern",
  "order": 1,
  "iconName": "directions_run",
  "isPremium": false
}
```

**Field Constraints:**

- `title`: Required, 3-100 characters, unique across categories
- `description`: Required, 10-500 characters
- `order`: Required, positive integer, should be unique (determines display order)
- `iconName`: Required, valid Material Icons name (Flutter uses Icons class)
- `isPremium`: Required, boolean (default: false)

**Document ID:** Use lowercase, hyphenated strings (e.g., "motorik", "schwangerschaft", "baby-sleep")

---

### Collection: `question/{questionId}`

Each question document represents a single quiz question with multiple choice answers.

**Document Structure:**

```typescript
interface Question {
  categoryId: string; // Reference to category document ID
  text: string; // The question text
  options: string[]; // Array of 3-4 answer options
  correctIndices: number[]; // Array of correct answer indices (0-based)
  explanation: string; // Detailed explanation shown after answering
  tips?: string; // Optional practical tips or advice related to the topic
  sourceLabel?: string; // Optional citation label (e.g., "Largo, R. H. (1993)")
  sourceUrl?: string; // Optional URL to source material
  difficulty: number; // 1 (easy), 2 (medium), 3 (hard)
  isActive: boolean; // Whether question appears in quiz rotation
}
```

**Example Document:**

```json
// Document ID: Auto-generated by Firestore
{
  "categoryId": "motorik",
  "text": "Was besagt Remo Largos Hauptbotschaft zur Geh-Entwicklung (Motorik)?",
  "options": [
    "Kinder, die krabbeln überspringen, sind motorisch im Vorteil.",
    "Alle gesunden Kinder sollten zwischen 12 und 14 Monaten laufen lernen.",
    "Der Zeitpunkt, zu dem ein Kind läuft, sagt nichts über seine spätere intellektuelle Entwicklung aus.",
    "Laufen ist immer gesünder, als Krabbeln."
  ],
  "correctIndices": [2],
  "explanation": "Remo Largo prägte den Satz: 'Das Gras wächst nicht schneller, wenn man daran zieht.' Seine Langzeitstudien zeigten: Die Entwicklungsspanne ist riesig. Manche gesunde Kinder laufen mit 9 Monaten, andere erst mit 20 Monaten. Beides ist völlig normal!",
  "tips": "Hände weg! Widerstehe dem Reflex, dein Kind an beiden Händen zu nehmen und herumzuführen. Das Kind hängt in deinen Armen, statt sein eigenes Gleichgewicht zu finden. Besser: Gestalte die Umgebung sicher und lass das Kind an Möbeln entlanglaufen.",
  "sourceLabel": "Largo, R. H. (1993/2010): Babyjahre",
  "sourceUrl": null,
  "difficulty": 2,
  "isActive": true
}
```

**Field Constraints:**

- `categoryId`: Required, must match an existing category document ID
- `text`: Required, 10-500 characters, the actual question
- `options`: Required array, 3-4 items, each 1-200 characters, all must be unique
- `correctIndices`: Required array, 1-3 items, values must be valid indices of options array
- `explanation`: Required, 20-2000 characters, supports plain text or markdown
- `tips`: Optional string, 0-1000 characters, practical advice or tips related to the topic
- `sourceLabel`: Optional string, 0-200 characters
- `sourceUrl`: Optional string, must be valid URL format if provided
- `difficulty`: Required integer, must be 1, 2, or 3
- `isActive`: Required boolean (default: true)

**Document ID:** Auto-generated by Firestore (use `.add()` or `.doc()` without ID)

**Important Notes:**

- `correctIndices` is 0-based (first option = 0, second = 1, etc.)
- Multiple correct answers are supported (e.g., `[0, 2]` means options 0 and 2 are both correct)
- Questions with `isActive: false` won't appear in the Flutter app quiz rotation
- The `categoryId` field creates a logical relationship but is NOT a Firestore reference type

---

### Collection: `admins/{email}`

Whitelist of admin users who can access the admin panel.

**Document Structure:**

```typescript
interface Admin {
  email: string; // Admin email address
  displayName: string; // Admin's full name
  createdAt: Timestamp; // When admin access was granted
  createdBy: string; // Email of admin who granted access
  role: "admin" | "superadmin"; // Permission level
}
```

**Example Document:**

```json
// Document ID: "admin@example.com"
{
  "email": "admin@example.com",
  "displayName": "John Doe",
  "createdAt": "2024-01-15T10:30:00Z",
  "createdBy": "superadmin@example.com",
  "role": "admin"
}
```

**Document ID:** Use the admin's email address as the document ID for easy lookup

---

## Zod Validation Schemas

These schemas ensure data integrity before writing to Firestore. They match the data model exactly:

```typescript
// lib/schemas/category.ts
import { z } from "zod";

export const categorySchema = z.object({
  title: z
    .string()
    .min(3, "Title must be at least 3 characters")
    .max(100, "Title must be less than 100 characters")
    .trim(),
  description: z
    .string()
    .min(10, "Description must be at least 10 characters")
    .max(500, "Description must be less than 500 characters")
    .trim(),
  order: z
    .number()
    .int("Order must be an integer")
    .positive("Order must be positive"),
  iconName: z
    .string()
    .min(1, "Icon name is required")
    .regex(/^[a-z_]+$/, "Icon name must be lowercase with underscores"),
  isPremium: z.boolean(),
});

export type CategoryFormData = z.infer<typeof categorySchema>;

// lib/schemas/question.ts
import { z } from "zod";

export const questionSchema = z.object({
  categoryId: z.string().min(1, "Category is required"),
  text: z
    .string()
    .min(10, "Question must be at least 10 characters")
    .max(500, "Question must be less than 500 characters")
    .trim(),
  options: z
    .array(
      z
        .string()
        .min(1, "Option cannot be empty")
        .max(200, "Option must be less than 200 characters")
        .trim()
    )
    .min(3, "Must have at least 3 options")
    .max(4, "Cannot have more than 4 options")
    .refine(
      (options) => new Set(options).size === options.length,
      "All options must be unique"
    ),
  correctIndices: z
    .array(z.number().int().min(0))
    .min(1, "Must select at least one correct answer")
    .max(3, "Cannot have more than 3 correct answers")
    .refine((indices, ctx) => {
      const options = ctx.parent?.options || [];
      return indices.every((i) => i < options.length);
    }, "Correct indices must be valid option indices"),
  explanation: z
    .string()
    .min(20, "Explanation must be at least 20 characters")
    .max(2000, "Explanation must be less than 2000 characters")
    .trim(),
  tips: z
    .string()
    .max(1000, "Tips must be less than 1000 characters")
    .trim()
    .optional()
    .nullable(),
  sourceLabel: z
    .string()
    .max(200, "Source label must be less than 200 characters")
    .trim()
    .optional()
    .nullable(),
  sourceUrl: z
    .string()
    .url("Must be a valid URL")
    .optional()
    .nullable()
    .or(z.literal("")),
  difficulty: z.union([z.literal(1), z.literal(2), z.literal(3)]),
  isActive: z.boolean(),
});

export type QuestionFormData = z.infer<typeof questionSchema>;
```

---

### Firestore Indexes Required

For optimal query performance, create these composite indexes:

1. **Questions by Category and Active Status:**

   - Collection: `question`
   - Fields: `categoryId` (Ascending), `isActive` (Ascending)
   - Query scope: Collection

2. **Questions by Difficulty:**

   - Collection: `question`
   - Fields: `difficulty` (Ascending), `isActive` (Ascending)
   - Query scope: Collection

3. **Categories by Order:**
   - Collection: `category`
   - Fields: `order` (Ascending)
   - Query scope: Collection

**Note:** Firestore will prompt you to create these indexes when you first run queries that need them.

---

### Data Relationships

```
category (motorik)
    ↓ (referenced by categoryId)
question (auto-id-1) → categoryId: "motorik"
question (auto-id-2) → categoryId: "motorik"
question (auto-id-3) → categoryId: "motorik"

category (schwangerschaft)
    ↓ (referenced by categoryId)
question (auto-id-4) → categoryId: "schwangerschaft"
question (auto-id-5) → categoryId: "schwangerschaft"
```

**Important:** These are NOT Firestore references (DocumentReference type), just string IDs. This is intentional for:

- Simpler queries
- Better performance
- Easier data export/import
- No cascade delete complexity

---

### TypeScript Type Definitions

For use in your Next.js admin panel:

```typescript
// types/category.ts
export interface Category {
  title: string;
  description: string;
  order: number;
  iconName: string;
  isPremium: boolean;
}

export interface CategoryWithId extends Category {
  id: string;
}

export interface CategoryWithStats extends CategoryWithId {
  questionCount: number;
  activeQuestionCount: number;
}

// types/question.ts
export interface Question {
  categoryId: string;
  text: string;
  options: string[];
  correctIndices: number[];
  explanation: string;
  tips?: string;
  sourceLabel?: string;
  sourceUrl?: string;
  difficulty: 1 | 2 | 3;
  isActive: boolean;
}

export interface QuestionWithId extends Question {
  id: string;
}

export interface QuestionWithCategory extends QuestionWithId {
  categoryTitle: string;
}

// types/admin.ts
export interface Admin {
  email: string;
  displayName: string;
  createdAt: Date;
  createdBy: string;
  role: "admin" | "superadmin";
}
```

---

### Firestore Security Rules

Recommended security rules for the admin panel:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is admin
    function isAdmin() {
      return exists(/databases/$(database)/documents/admins/$(request.auth.token.email));
    }

    // Categories - admins can read/write
    match /category/{categoryId} {
      allow read: if true; // Public read for Flutter app
      allow write: if isAdmin();
    }

    // Questions - admins can read/write
    match /question/{questionId} {
      allow read: if true; // Public read for Flutter app
      allow write: if isAdmin();
    }

    // Admins collection - only superadmins can modify
    match /admins/{email} {
      allow read: if isAdmin();
      allow write: if isAdmin() &&
        get(/databases/$(database)/documents/admins/$(request.auth.token.email)).data.role == 'superadmin';
    }

    // User data (existing rules for Flutter app)
    match /user/{userId} {
      allow read, write: if request.auth.uid == userId;
      // ... other user-related rules
    }
  }
}
```

## Tech Stack

### Frontend

- **Framework**: Next.js 14+ (App Router)
- **Language**: TypeScript
- **Styling**: Tailwind CSS
- **UI Components**: shadcn/ui (or Radix UI primitives)
- **Forms**: React Hook Form + Zod validation
- **State Management**: React Query (TanStack Query) for server state
- **Rich Text Editor**: Tiptap or Lexical (for explanations)
- **Authentication**: Firebase Auth (admin users only)

### Backend/API

- **API Routes**: Next.js API Routes (App Router route handlers)
- **Database**: Firebase Firestore (existing schema)
- **Authentication**: Firebase Admin SDK for server-side auth
- **Validation**: Zod schemas matching Firestore schema

## Architecture

```
admin-panel/
├── app/
│   ├── (auth)/
│   │   ├── login/
│   │   └── layout.tsx
│   ├── (dashboard)/
│   │   ├── categories/
│   │   │   ├── page.tsx           # List all categories
│   │   │   ├── new/page.tsx       # Create category
│   │   │   └── [id]/edit/page.tsx # Edit category
│   │   ├── questions/
│   │   │   ├── page.tsx           # List/filter questions
│   │   │   ├── new/page.tsx       # Create question
│   │   │   └── [id]/edit/page.tsx # Edit question
│   │   ├── preview/
│   │   │   └── [id]/page.tsx      # Preview question as user sees it
│   │   └── layout.tsx             # Dashboard layout with nav
│   ├── api/
│   │   ├── categories/
│   │   │   ├── route.ts           # GET, POST
│   │   │   └── [id]/route.ts      # GET, PUT, DELETE
│   │   └── questions/
│   │       ├── route.ts           # GET (with filters), POST
│   │       └── [id]/route.ts      # GET, PUT, DELETE
│   └── layout.tsx
├── components/
│   ├── ui/                        # shadcn/ui components
│   ├── forms/
│   │   ├── CategoryForm.tsx
│   │   ├── QuestionForm.tsx
│   │   └── OptionInput.tsx
│   ├── tables/
│   │   ├── CategoriesTable.tsx
│   │   └── QuestionsTable.tsx
│   └── layout/
│       ├── Sidebar.tsx
│       └── Header.tsx
├── lib/
│   ├── firebase/
│   │   ├── admin.ts               # Firebase Admin SDK
│   │   ├── client.ts              # Firebase Client SDK
│   │   └── auth.ts                # Auth helpers
│   ├── schemas/
│   │   ├── category.ts            # Zod schemas
│   │   └── question.ts
│   └── utils.ts
└── types/
    ├── category.ts
    └── question.ts
```

## Core Features

### 1. Authentication

- Admin-only access (check user email against whitelist in Firestore)
- Firebase Authentication integration
- Protected routes with middleware
- Session management

### 2. Category Management

#### List View

- Table showing all categories
- Columns: Title, Description, Order, Premium Status, Question Count, Actions
- Sort by order or title
- Quick toggle for isPremium status
- Drag-and-drop reordering

#### Create/Edit Form

```typescript
interface CategoryForm {
  title: string; // Required, max 100 chars
  description: string; // Required, max 500 chars
  order: number; // Auto-increment or manual
  iconName: string; // Material icon name with preview
  isPremium: boolean; // Toggle
}
```

**Validation Rules:**

- Title: Required, 3-100 characters
- Description: Required, 10-500 characters
- Order: Positive integer, unique
- IconName: Valid Material icon name (with autocomplete)

### 3. Question Management

#### List View

- Filterable table with:
  - Category filter (dropdown)
  - Difficulty filter (1-3)
  - Active/Inactive filter
  - Search by question text
- Columns: Question (truncated), Category, Difficulty, Active, Actions
- Bulk actions: Activate/Deactivate, Delete
- Pagination (20 per page)

#### Create/Edit Form

```typescript
interface QuestionForm {
  categoryId: string; // Dropdown of categories
  text: string; // Question text, required
  options: string[]; // 3-4 options, dynamic array
  correctIndices: number[]; // Checkboxes for each option
  explanation: string; // Rich text editor
  tips?: string; // Optional practical tips/advice
  sourceLabel?: string; // Optional citation
  sourceUrl?: string; // Optional URL
  difficulty: 1 | 2 | 3; // Radio buttons or select
  isActive: boolean; // Toggle (default true)
}
```

**Validation Rules:**

- Text: Required, 10-500 characters
- Options: 3-4 items, each 1-200 characters, all unique
- CorrectIndices: At least 1 selected, max 3
- Explanation: Required, 20-2000 characters
- Tips: Optional, 0-1000 characters
- SourceUrl: Valid URL if provided
- Difficulty: 1 (Easy), 2 (Medium), 3 (Hard)

**Smart Features:**

- Auto-save drafts to localStorage
- Duplicate question button
- Preview mode (shows question as it appears in app)
- Character counters on all text fields
- Markdown support in explanation field

### 4. Preview Mode

- Shows question exactly as users see it in the Flutter app
- Mobile-responsive preview
- Test answer selection
- View explanation after answering

## API Design

### Categories API

```typescript
// GET /api/categories
// Returns all categories sorted by order
Response: Category[]

// POST /api/categories
// Creates new category
Body: CategoryForm
Response: { id: string; category: Category }

// GET /api/categories/[id]
// Returns single category with question count
Response: Category & { questionCount: number }

// PUT /api/categories/[id]
// Updates category
Body: Partial<CategoryForm>
Response: Category

// DELETE /api/categories/[id]
// Deletes category (only if no questions exist)
Response: { success: boolean }
```

### Questions API

```typescript
// GET /api/questions?categoryId=X&difficulty=2&isActive=true&search=text
// Returns filtered questions with pagination
Response: {
  questions: Question[];
  total: number;
  page: number;
  pageSize: number;
}

// POST /api/questions
// Creates new question
Body: QuestionForm
Response: { id: string; question: Question }

// GET /api/questions/[id]
// Returns single question
Response: Question

// PUT /api/questions/[id]
// Updates question
Body: Partial<QuestionForm>
Response: Question

// DELETE /api/questions/[id]
// Soft delete (sets isActive: false) or hard delete
Response: { success: boolean }
```

## Backend Implementation

### Firebase Admin Setup

```typescript
// lib/firebase/admin.ts
import { initializeApp, getApps, cert } from "firebase-admin/app";
import { getFirestore } from "firebase-admin/firestore";
import { getAuth } from "firebase-admin/auth";

if (!getApps().length) {
  initializeApp({
    credential: cert({
      projectId: process.env.FIREBASE_PROJECT_ID,
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
      privateKey: process.env.FIREBASE_PRIVATE_KEY?.replace(/\\n/g, "\n"),
    }),
  });
}

export const adminDb = getFirestore();
export const adminAuth = getAuth();
```

### Authentication Middleware

```typescript
// lib/firebase/auth.ts
import { adminAuth, adminDb } from "./admin";
import { cookies } from "next/headers";

export async function verifyAdmin(token: string): Promise<boolean> {
  try {
    const decodedToken = await adminAuth.verifyIdToken(token);
    const userEmail = decodedToken.email;

    // Check if user is in admin whitelist
    const adminDoc = await adminDb.collection("admins").doc(userEmail).get();

    return adminDoc.exists;
  } catch (error) {
    return false;
  }
}

export async function requireAuth() {
  const cookieStore = cookies();
  const token = cookieStore.get("auth-token")?.value;

  if (!token || !(await verifyAdmin(token))) {
    throw new Error("Unauthorized");
  }
}
```

### API Route Example

```typescript
// app/api/questions/route.ts
import { NextRequest, NextResponse } from "next/server";
import { adminDb } from "@/lib/firebase/admin";
import { requireAuth } from "@/lib/firebase/auth";
import { questionSchema } from "@/lib/schemas/question";

export async function GET(request: NextRequest) {
  try {
    await requireAuth();

    const { searchParams } = new URL(request.url);
    const categoryId = searchParams.get("categoryId");
    const difficulty = searchParams.get("difficulty");
    const isActive = searchParams.get("isActive");
    const search = searchParams.get("search");

    let query = adminDb.collection("question");

    if (categoryId) {
      query = query.where("categoryId", "==", categoryId);
    }
    if (difficulty) {
      query = query.where("difficulty", "==", parseInt(difficulty));
    }
    if (isActive !== null) {
      query = query.where("isActive", "==", isActive === "true");
    }

    const snapshot = await query.get();
    let questions = snapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));

    // Client-side search for text (Firestore doesn't support full-text search)
    if (search) {
      questions = questions.filter((q) =>
        q.text.toLowerCase().includes(search.toLowerCase())
      );
    }

    return NextResponse.json({ questions });
  } catch (error) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
}

export async function POST(request: NextRequest) {
  try {
    await requireAuth();

    const body = await request.json();
    const validated = questionSchema.parse(body);

    const docRef = await adminDb.collection("question").add(validated);

    return NextResponse.json({
      id: docRef.id,
      question: validated,
    });
  } catch (error) {
    return NextResponse.json({ error: error.message }, { status: 400 });
  }
}
```

## UI/UX Guidelines

### Design System

- **Colors**:

  - Primary: Blue (#3B82F6) for actions
  - Success: Green (#10B981) for active/correct
  - Warning: Yellow (#F59E0B) for medium difficulty
  - Danger: Red (#EF4444) for delete/hard difficulty
  - Neutral: Gray scale for backgrounds

- **Typography**:

  - Headings: Inter or System UI font
  - Body: Same as headings for consistency
  - Code/IDs: Monospace font

- **Spacing**: Consistent 4px grid (Tailwind default)

### Key Components

#### Question Form

- Split into sections: Basic Info, Options, Explanation, Metadata
- Live character counters
- Option management with add/remove buttons
- Checkbox next to each option for marking correct
- Rich text editor for explanation with toolbar
- Preview button that opens modal

#### Tables

- Sticky header on scroll
- Row hover effects
- Inline edit for simple fields (isActive toggle)
- Action menu (3-dot) for edit/delete/duplicate
- Empty states with helpful CTAs

#### Validation

- Real-time validation with error messages
- Prevent form submission if invalid
- Clear error indicators on fields
- Success toast notifications on save

## Environment Variables

```env
# Firebase Admin
FIREBASE_PROJECT_ID=your-project-id
FIREBASE_CLIENT_EMAIL=your-service-account@project.iam.gserviceaccount.com
FIREBASE_PRIVATE_KEY="-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n"

# Firebase Client (for auth)
NEXT_PUBLIC_FIREBASE_API_KEY=your-api-key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=your-project.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=your-project-id

# App
NEXT_PUBLIC_APP_URL=http://localhost:3000
```

## Security Considerations

1. **Admin Whitelist**: Store admin emails in Firestore `admins` collection
2. **Server-Side Validation**: Always validate on API routes, not just client
3. **Rate Limiting**: Implement rate limiting on API routes
4. **CORS**: Restrict API access to admin panel domain only
5. **Audit Log**: Log all create/update/delete operations with user email and timestamp

## Deployment

### Recommended: Vercel

- Automatic deployments from Git
- Environment variables in dashboard
- Edge functions for API routes
- Built-in analytics

### Alternative: Firebase Hosting + Cloud Functions

- Host Next.js on Firebase Hosting
- API routes as Cloud Functions
- Unified Firebase ecosystem

## Future Enhancements

- **Analytics Dashboard**: Question performance, category popularity
- **Bulk Import**: CSV/JSON upload for questions
- **Version History**: Track changes to questions
- **Collaboration**: Multiple admins with activity feed
- **AI Assistance**: Generate question variations or explanations
- **Image Support**: Upload images for questions
- **Translation Management**: Multi-language support

## Getting Started Command

```bash
npx create-next-app@latest quiz-admin --typescript --tailwind --app
cd quiz-admin
npm install firebase firebase-admin react-hook-form zod @tanstack/react-query
npx shadcn-ui@latest init
```

## Summary

This admin panel provides a professional, user-friendly interface for managing quiz content. The Next.js architecture ensures fast performance, the Firebase integration maintains consistency with your Flutter app, and the component-based design allows for easy maintenance and future enhancements.
